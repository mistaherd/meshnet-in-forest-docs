\section{Python Scripts}
\subsection{DHT22}
\begin{lstlisting}[style=mystyle,caption={DHT22code}]
#!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
import adafruit_dht 
import board
import datetime
import pandas as pd
class DHT22:
##Set DATA pin to pin 4
    def __init__(self):
        # self.dhtDevice =adafruit_dht.DHT22(board.D4)
        self.dhtDevice =adafruit_dht.DHT11(board.D4)
    def Read_DHT22_data(self)-> tuple[float,float,str]:
        try:
            Humidity=self.dhtDevice.humidity
            Temperature=self.dhtDevice.temperature
            timestamp =datetime.datetime.now()
            timestamp = timestamp.strftime("%Y-%m-%d %H:%M:%S")
            return Temperature,Humidity,timestamp
        except RuntimeError as e:
            print(f"Error reading sensor: {e}")
            return None, None
    def write_to_csv(self,filename:str):
        temperature, humidity, timestamp = self.Read_DHT22_data()
        if temperature is not None and humidity is not None and timestamp is not None:
            data = [(temperature, humidity, timestamp)]
            df = pd.DataFrame(data, columns=['Temperature', 'Humidity', 'Timestamp'])
            df.to_csv(filename, index=False)
        else:
            print("Failed to retrieve data from sensor. Data not written to CSV.")
dht_sensor = DHT22()
dht_sensor.write_to_csv("sensor_data.csv")
\end{lstlisting}
\newpage
\subsection{AS312}
\begin{lstlisting}[style=mystyle,caption={code for  AS312}]
#!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
import RPi.GPIO as GPIO
import time
import datetime
import pandas as pd
#pin 17
class AS312:
	def __init__(self,pin_number:int):
		self.pin_number=pin_number
		self.GPIO=GPIO
		self.GPIO.setmode(GPIO.BCM)
		self.GPIO.setup(self.pin_number,GPIO.IN)
		self.current_state=0
		self.timestamp=datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
	def read_state(self)->int:
		self.current_state =self.GPIO.input(self.pin_number)
		return self.current_state
	def append_data(self):
		data={
			"Motion Dectected": [self.current_state],
			"Timestamp": [self.timestamp]
		}
		df =pd.DataFrame(data)
		df.to_csv('sensor_data.csv',mode='a' ,index=False,header=False)
pir_sensor = AS312(17)
try:
	time.sleep(0.1)
	current_state =pir_sensor.read_state()
	timestamp=pir_sensor.timestamp
	print("GPIO pin %s is %s" % (pir_sensor.pin_number,current_state))
	if current_state == 1:
		print("Motion dectected")
	pir_sensor.append_data()
except KeyboardInterrupt:
	pass
finally:
	GPIO.cleanup()
\end{lstlisting}


\newpage
\subsection{DFR0026}
\begin{lstlisting}[style=mystyle,caption={Code for  DFR00026}]
#!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
from DFRobot_ADS1115 import ADS1115
import time
class DFR0026():
    def __init__(self):
        self.ADS1115_REG_CONFIG_PGA_6_144V        = 0x00 # 6.144V range = Gain 2/3
        self.ADS1115_REG_CONFIG_PGA_4_096V        = 0x02 # 4.096V range = Gain 1
        self.ADS1115_REG_CONFIG_PGA_2_048V        = 0x04 # 2.048V range = Gain 2 (default)
        self.ADS1115_REG_CONFIG_PGA_1_024V        = 0x06 # 1.024V range = Gain 4
        self.ADS1115_REG_CONFIG_PGA_0_512V        = 0x08 # 0.512V range = Gain 8
        self.ADS1115_REG_CONFIG_PGA_0_256V        = 0x0A # 0.256V range = Gain 16
        self.ads1115 = ADS1115()
        self.ads1115.set_addr_ADS1115(0x48)
        self.ads1115.set_gain(self.ADS1115_REG_CONFIG_PGA_6_144V)
        self.adc_channel=0
    def read_voltage(self):
        return self.ads1115.read_voltage(self.adc_channel)
        #time.sleep(0.2) after read it
light_vaule=DFR0026()
print(light_vaule.read_voltage())  

\end{lstlisting}
\newpage
\subsection{Camera}
\begin{lstlisting}[style=mystyle,caption={Code for Camera}]
#!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
from picamera import PiCamera
from time import sleep
from datetime import datetime
class Raspberry_Pi_VR_220:
    def __init__(self):
        """setup an instan  for the  camera"""
        self.timestamp=datetime.now().strftime("%Y-%m-%d_%H:%M:%S")
        self.fname ='/home/mistaherd/Documents/Github/meshnetwork_in_forest/{}.png'.format(self.timestamp)
        self.camera=PiCamera()
        self.timeamount=2
    def take_pic(self)-> str:
        """this will take  a picture from camera"""
        self.camera.start_preview()
        sleep(self.timeamount)
        self.camera.capture(self.fname)
        self.stop_preview()
        return self.fname
camera=Raspberry_Pi_VR_220()
picture=camera.take_pic()
\end{lstlisting}
\newpage
\subsubsection{Camera alt}
\begin{lstlisting}[style=mystyle,caption={Code for alternaive code for Camera}]
	#!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
	import subprocess
	class camera:
		def __init__(self):
			self.run=subprocess.run(["bash","/home/mistaherd/Documents/Github/meshnetwork_in_forest/bash_scrpits/camerea.sh"])
	if __name__=="__main__":
		camera()
\end{lstlisting}
\newpage 
\subsection{Memory management}
\begin{lstlisting}[style=mystyle,caption={Code for  memory mangement}]
#!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
import pandas as pd
from DHT22 import DHT22
from AS312 import AS312
from MCP3008 import DF0026
import glob
import re 
import subprocess
class sensor_data:
	def __init__(self):
		self.dht22 = DHT22()
		self.humidity,self.temperature,self.timestamp=self.dht22.Read_DHT22_data()
		self.AS312=AS312(17)
		self.motion_dected =AS312.read_state()
		self.DF0026 =DF0026()
		self.light_value=self.DF0026.Read_data()
		self.fname="sensor_data.csv"
	def write_append_csv(self):
		data = { "Timestamp" : self.timestamp,
			"Temperature(oc)" : self.Temperature,
			"Humidity(%)" : self.humidity,
			"Light(lux)" :self.light_value,
			"Motion Dected": self.motion_dected
			}
		df = pd.DataFrame(data)
		if glob.glob(self.fname):	
			df.to_csv(self.fname,mode='a' ,index=False,header=False)
		else:
			df.to_csv(self.fname,mode='w' ,index=False)
class Memory_tester():
	def __init__(self):
		self.units={"K":10e3,"M": 10e6,"G":10e9}
		self.regex ="\d{4}\.\[0-9]{1,3}[K,M,G]"
		self.fname="../bash_scrpits/memorytest.sh" 
		self.output_bash=subprocess.check_output(["bash",self.fname],universal_newlines=True)
	def check_memory(self):
		try:
			if re.search(self.regex,self.output_bash):
				value,unit=match.group(0).split()
				try:
					return float(value)*self.units[unit]
				except KeyError:
					raise ValueError(f"unknown unit: {unit}")
			
		except subprocess.CalledProcessError as e:
			raise ValueError(f"Error running script:{e.output}")
	def error_check(self):
		mem=self.check_memory()
		max=32*10e9
		if mem >= 0.2* max:
			raise MemoryError("memory on pi is about to  used up")		
\end{lstlisting}
\subsection{Radio module}
\begin{lstlisting}[style=mystyle,caption={Code for Radio module}]
	#!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
	import time
	import serial
	import pandas as pd
	import numpy as np
	import threading
	import subprocess
	import base64
	from memory_mangment import sensor_data
	class Transciever:
		def __init__(self):
			self.transceive_ser=serial.Serial(port='/dev/ttyS0',baudrate=9600,parity=serial.PARITY_NONE,stopbits=serial.STOPBITS_ONE,bytesize=serial.EIGHTBITS,timeout=1)
			self.message="Hello world!"
			self.chunk_size=240
			self.txt_fname="/home/mistaherd/Documents/Github/meshnetwork_in_forest/Tests/transmited_text.txt"
			self.csv_fname=sensor_data().fname
			self.timelimit=time.time()+6
			self.recived=self.transceive_ser.in_waiting
			self.event=threading.Event()
		def serial_interrupt(self):
			if self.recived:
				self.event.set()
		def cal_bytes(self)-> int:
			return len([bytes(self.data[i],'utf-8').hex() for i in range(len(self.data))])

		# hello world
		def transceive_test_message(self,transceive:bool):
			"""send /recive a hello world"""
			if transceive:
				# self.message
				#transmite
				self.transceive_ser.write(bytes(self.message,'utf-8'))
				time.sleep(0.2)
			if not transceive:
				while time.time()< self.reive_timelimit:
					self.transceive_ser.attachInterrupt(self.serial_interrupt)
					if self.event.is_set():
						data_read=self.transceive_ser.readline()
						data=data_read.decode("utf-8")
						print("message received:",data)
						self.event.clear()
		# Text file
		def transceive_test_txt_file(self,transceive:bool):
			"""send /revive a txt file"""
			if transceive:
				with open(self.txt_fname,'r') as f:
					data=f.read()

				self.transceive_ser.write(bytes(data,'utf-8'))
				time.sleep(0.2)
			if not transceive:
				while time.time()< self.timelimit:
					self.transceive_ser.attachInterrupt(self.serial_interrupt)
					if self.event.is_set():
						data_read=self.transceive_ser.readline()
						data=data_read.decode("utf-8")
						print(data)
		#test csv file
		def transceive_test_csv(self,transceive:bool):
			if transceive:
				with open('/home/mistaherd/Documents/Github/meshnetwork_in_forest/main/sensor_data.csv','r') as f:
					data=f.readlines()
				data=''.join(data)
				lora.write(bytes(data,'utf-8'))
				time.sleep(0.2)
			if not transceive:
				while time.time() <self.timelimit:
					self.transceive_ser.attachInterrupt(self.serial_interrupt)
					if self.event.is_set():
						data=self.transceive_ser.readlines()
						output=[data[i].decode()[:-1].split(",") for i in range(len(data))]
						df=pd.DataFrame(output)
						print(df)

		#Test png,jpg
		def Transcevie_png_file(self):
			"""Transmit a PNG file"""
			if transceive:
				with open(self.png_fname, 'rb') as f:
					data = f.read()
				chunks=[data[i:i+self.chunk_size] for i in range(0,len(data),self.chunk_size)]
				for chunk in range(len(chunks)):
					encoded_chunk=base64.b64encode(chunk)
					self.transceive_ser.write(encoded_chunk)
			if not transceive:
				output=[]
				self.transceive_ser.attachInterrupt(self.serial_interrupt)
				if self.event.is_set():
					while(self.transceive_ser.read() != b''):
						data_read = self.transceive_ser.read()
						print("bytes reviced %a"%data_read)
						output.append(base64.b64decode(data_read))
					output=b"".join(output)
					with open("recived_img.png", 'wb') as f:
							f.write(output)
		def transive_choice(self,arugement):
			""" run this for demo"""
			if not self.event.is_set():
				#transmit something
				self.transmit=True
				choice ={
					1:lambda :self.transceive_test_message(self.transmit),
					2:lambda :self.transceive_test_txt_file(self.transmite),
					3:lambda :self.transceive_test_csv(self.transmit),
					4:lambda :self.Transcevie_png_file(self.transmit)}
				choice[arugement]()
			#revived somthing
			self.transmit=False
			choice[self.user_message]()
	if __name__=='__main__':
		Transciever()
	
\end{lstlisting}