\subsection{DHT22}
\begin{lstlisting}[style=mystyle,caption={DHT22code}]
#!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
import adafruit_dht 
import board
import datetime
import pandas as pd
class DHT22:
##Set DATA pin to pin 4
    def __init__(self):
        # self.dhtDevice =adafruit_dht.DHT22(board.D4)
        self.dhtDevice =adafruit_dht.DHT11(board.D4)
    def Read_DHT22_data(self)-> tuple[float,float,str]:
        try:
            Humidity=self.dhtDevice.humidity
            Temperature=self.dhtDevice.temperature
            timestamp =datetime.datetime.now()
            timestamp = timestamp.strftime("%Y-%m-%d %H:%M:%S")
            return Temperature,Humidity,timestamp
        except RuntimeError as e:
            print(f"Error reading sensor: {e}")
            return None, None
    def write_to_csv(self,filename:str):
        temperature, humidity, timestamp = self.Read_DHT22_data()
        if temperature is not None and humidity is not None and timestamp is not None:
            data = [(temperature, humidity, timestamp)]
            df = pd.DataFrame(data, columns=['Temperature', 'Humidity', 'Timestamp'])
            df.to_csv(filename, index=False)
        else:
            print("Failed to retrieve data from sensor. Data not written to CSV.")
dht_sensor = DHT22()
dht_sensor.write_to_csv("sensor_data.csv")
\end{lstlisting}
\newpage
\subsection{AS312}
\begin{lstlisting}[style=mystyle,caption={code for  AS312}]
#!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
import RPi.GPIO as GPIO
import time
import datetime
import pandas as pd
#pin 17
class AS312:
	def __init__(self,pin_number:int):
		self.pin_number=pin_number
		self.GPIO=GPIO
		self.GPIO.setmode(GPIO.BCM)
		self.GPIO.setup(self.pin_number,GPIO.IN)
		self.current_state=0
		self.timestamp=datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
	def read_state(self)->int:
		self.current_state =self.GPIO.input(self.pin_number)
		return self.current_state
	def append_data(self):
		data={
			"Motion Dectected": [self.current_state],
			"Timestamp": [self.timestamp]
		}
		df =pd.DataFrame(data)
		df.to_csv('sensor_data.csv',mode='a' ,index=False,header=False)
pir_sensor = AS312(17)
try:
	time.sleep(0.1)
	current_state =pir_sensor.read_state()
	timestamp=pir_sensor.timestamp
	print("GPIO pin %s is %s" % (pir_sensor.pin_number,current_state))
	if current_state == 1:
		print("Motion dectected")
	pir_sensor.append_data()
except KeyboardInterrupt:
	pass
finally:
	GPIO.cleanup()
\end{lstlisting}


\newpage
\subsection{DFR0026}
\begin{lstlisting}[style=mystyle,caption={Code for  DFR00026}]
#!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
from DFRobot_ADS1115 import ADS1115
import time
class DFR0026():
    def __init__(self):
        self.ADS1115_REG_CONFIG_PGA_6_144V        = 0x00 # 6.144V range = Gain 2/3
        self.ADS1115_REG_CONFIG_PGA_4_096V        = 0x02 # 4.096V range = Gain 1
        self.ADS1115_REG_CONFIG_PGA_2_048V        = 0x04 # 2.048V range = Gain 2 (default)
        self.ADS1115_REG_CONFIG_PGA_1_024V        = 0x06 # 1.024V range = Gain 4
        self.ADS1115_REG_CONFIG_PGA_0_512V        = 0x08 # 0.512V range = Gain 8
        self.ADS1115_REG_CONFIG_PGA_0_256V        = 0x0A # 0.256V range = Gain 16
        self.ads1115 = ADS1115()
        self.ads1115.set_addr_ADS1115(0x48)
        self.ads1115.set_gain(self.ADS1115_REG_CONFIG_PGA_6_144V)
        self.adc_channel=0
    def read_voltage(self):
        return self.ads1115.read_voltage(self.adc_channel)
        #time.sleep(0.2) after read it
light_vaule=DFR0026()
print(light_vaule.read_voltage())  

\end{lstlisting}
\newpage
\subsection{Camera}
\begin{lstlisting}[style=mystyle,caption={Code for Camera}]
#!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
from picamera import PiCamera
from time import sleep
from datetime import datetime
class Raspberry_Pi_VR_220:
    def __init__(self):
        """setup an instan  for the  camera"""
        self.timestamp=datetime.now().strftime("%Y-%m-%d_%H:%M:%S")
        self.fname ='/home/mistaherd/Documents/Github/meshnetwork_in_forest/{}.png'.format(self.timestamp)
        self.camera=PiCamera()
        self.timeamount=2
    def take_pic(self)-> str:
        """this will take  a picture from camera"""
        self.camera.start_preview()
        sleep(self.timeamount)
        self.camera.capture(self.fname)
        self.stop_preview()
        return self.fname
camera=Raspberry_Pi_VR_220()
picture=camera.take_pic()
\end{lstlisting}
\newpage 
\subsection{Memory mangement}
\begin{lstlisting}[style=mystyle,caption={Code for  memory mangement}]
#!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
import pandas as pd
# from DHT22 import DHT22

# from AS312 import AS312
# from MCP3008 import DF0026
import pandas as pd
import glob
import re 
import subprocess
class sensor_data:
	def __init__(self):
		self.dht22 = DHT22()
		self.humidity,self.temperature,self.timestamp=self.dht22.Read_DHT22_data()
		self.AS312=AS312(17)
		self.motion_dected =AS312.read_state()
		self.DF0026 =DF0026()
		self.light_value=self.DF0026.Read_data()
		self.fname="sensor_data.csv"
	def write_append_csv(self):
		data = { "Timestamp" : self.timestamp,
			"Temperature(oc)" : self.Temperature,
			"Humidity(%)" : self.humidity,
			"Light(lux)" :self.light_value,
			"Motion Dected": self.motion_dected
			}
		df = pd.DataFrame(data)
		if glob.glob(self.fname):	
			df.to_csv(self.fname,mode='a' ,index=False,header=False)
		else:
			df.to_csv(self.fname,mode='w' ,index=False)
class Memory_tester():
	def __init__(self):
		self.units={"K":10e3,"M": 10e6,"G":10e9}
		self.regex ="\d{4}\.\[0-9]{1,3}[K,M,G]"
		self.fname="../bash_scrpits/memorytest.sh" 
		self.output_bash=subprocess.check_output(["bash",self.fname],universal_newlines=True)
	def check_memory(self):
		try:
			if re.search(self.regex,self.output_bash):
				value,unit=match.group(0).split()
				try:
					return float(value)*self.units[unit]
				except KeyError:
					raise ValueError(f"unknown unit: {unit}")
			
		except subprocess.CalledProcessError as e:
			raise ValueError(f"Error running script:{e.output}")
	def error_check(self):
		mem=self.check_memory()
		max=32*10e9
		if mem >= 0.2* max:
			raise MemoryError("memory on pi is about to  used up")
		
\end{lstlisting}
