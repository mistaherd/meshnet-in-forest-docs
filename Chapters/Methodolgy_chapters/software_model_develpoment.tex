This section is here to discuss the method we took  for  developing software  for the  following:
\begin{enumerate}
    \item Sensors 
    \item ADC
    \item Camera
    \item Radio module
    \item Memory management
    \item TDD
\end{enumerate}
\subsection{Sensors}
This Section will discuss the following:
\begin{enumerate}
    \item DHT22
    \item AS312
    \item DFR0026
\end{enumerate}
To see the light sensor look on page \pageref{ADC section} 
\subsubsection{DHT22}
For this section we used the following libraries:
\begin{lstlisting}[style=mystyle,numbers=left,firstnumber=1]
#!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
import adafruit_dht 
import board
import pandas as pd  
\end{lstlisting} 
This uses the library from \href{https://github.com/mrmcwethy/Adafruit_CircuitPython_DHT}{this link}
\begin{enumerate}
    \item we define the our class
    \begin{lstlisting}[style=mystyle,numbers=left,firstnumber=1]
    class DHT22:
    ##Set DATA pin to pin 4
        def __init__(self):
            """this will setup the  data pin  for  DHT2"""
            # self.dhtDevice =adafruit_dht.DHT22(board.D4)
            self.dhtDevice =adafruit_dht.DHT11(board.D4)
            self.humidity=self.dhtDevice.humidity
            self.temperature=self.dhtDevice.temperature
    \end{lstlisting}
    In this class we have  define our DhT device as 11 seen as the DHT22 was  broken
    so we set  our gpio pin 4 and setup the variables that read the  sensor data
    \item Next we read the data from the following function.
    \begin{lstlisting}[style=mystyle,numbers=left,firstnumber=1]
        def Read_DHT22_data(self)-> tuple[float,float,str]:
        """This  will setup a DHT instance and  return the data from the sensor"""
        try:
            return self.temperature,self.humidity
        except RuntimeError as e:
            print(f"Error reading sensor: {e}")
            return None, None
    \end{lstlisting}
    this will  return out the  temperature and humidity if the sensor is not connected
    this  will return nothing . next  use the following: 
    \begin{lstlisting}[style=mystyle,numbers=left,firstnumber=1]
        if __name__ =="__main__":
            DHT22()
    \end{lstlisting}
\end{enumerate}
\subsubsection{AS312}
\begin{enumerate}

\item For this we import the following libraries:

\begin{lstlisting}[style=mystyle,,numbers=left,firstnumber=1]
    #!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
    import RPi.GPIO as GPIO
    import time
\end{lstlisting}

    \item next  we set up our variables  in the class

    \begin{lstlisting}[style=mystyle,numbers=left,firstnumber=1]
    class AS312:
	def __init__(self):
		"connect the AS312 to pin 17"
		self.pin_number=17
		self.GPIO=GPIO
		self.GPIO.setmode(GPIO.BCM)
		self.GPIO.setup(self.pin_number,GPIO.IN)
		self.current_state=0
    \end{lstlisting}
    This sets current state as 0
    \item next  we detect  movement
    \begin{lstlisting}[style=mystyle]
        def read_state(self)->bool:
            time.sleep(0.1)
            self.current_state =bool(self.GPIO.input(self.pin_number))
            return self.current_state
    \end{lstlisting}

\end{enumerate}

\subsubsection{DFR0026}
\label{ADC section}
From the repository DFRobot_ADS1115 the following is considered:
\begin{enumerate}

    \item Import the libraries: 
\begin{lstlisting}[style=mystyle]
#!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
from DFRobot_ADS1115 import ADS1115
import time
\end{lstlisting}
    
    \item Define our variables:
\begin{lstlisting}[style=mystyle]
class DFR0026():
    def __init__(self):
        self.ADS1115_REG_CONFIG_PGA_6_144V = 0x00  # 6.144V range = Gain 2/3
        self.ADS1115_REG_CONFIG_PGA_4_096V = 0x02  # 4.096V range = Gain 1
        self.ADS1115_REG_CONFIG_PGA_2_048V = 0x04  # 2.048V range = Gain 2 (default)
        self.ADS1115_REG_CONFIG_PGA_1_024V = 0x06  # 1.024V range = Gain 4
        self.ADS1115_REG_CONFIG_PGA_0_512V = 0x08  # 0.512V range = Gain 8
        self.ADS1115_REG_CONFIG_PGA_0_256V = 0x0A  # 0.256V range = Gain 16
        self.ads1115 = ADS1115()
        self.ads1115.set_addr_ADS1115(0x48)
        self.ads1115.set_gain(self.ADS1115_REG_CONFIG_PGA_6_144V)
        self.adc_channel = 0
\end{lstlisting}
    This configures all the pins and sets the associative gain.
    
    \item Read the analog channel:

\begin{lstlisting}[style=mystyle]
    def read_voltage(self):
        return self.ads1115.read_voltage(self.adc_channel)
\end{lstlisting}
\end{enumerate}
    
\newpage
\subsection{Camera}
Here are the steps for module development of the Camera:
\begin{enumerate}
    \item install the following libraries:
    \begin{lstlisting}[style=mystyle]
        #!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
        from picamera2 import Picamera2 ,Preview
        from time import sleep
        from datetime import datetime
    \end{lstlisting}
    \item we dine our class variables
    \begin{lstlisting}[style=mystyle]
    class Raspberry_Pi_VR_220:
        def __init__(self):
            """setup an instan  for the  camera"""
            self.timestamp=datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
            self.fname ='/home/mistaherd/Documents/Github/meshnetwork_in_forest/Images_camera/{}.png'.format(self.timestamp)
            self.camera=Picamera2()
            self.camera_config=self.camera.create_preview_configuration()
            self.timeamount=2
    \end{lstlisting}
    \item  make the function for  takeing  a  picture
    \begin{lstlisting}[style=mystyle]
        def take_pic(self)-> str:
            """this will take  a picture from camera"""
            self.camera.configure(self.camera_config)
            self.camera.start_preview(Preview.QTGL)
            self.camera.start()
            sleep(self.timeamount)
            self.camera.capture_file(self.fname)
            return self.fname
    \end{lstlisting}
\end{enumerate}
\newpage
\subsection{Memory Management}
For this we want to  read data  and append and check it the memory size.Here are the following steps:
\begin{enumerate}
    \item  import the following  libraries:
    \begin{lstlisting}[style=mystyle]
        #!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
        import pandas as pd
        from DHT22 import DHT22
        from AS312 import AS312
        from DFR0026 import DFR0026
        import glob
        import re 
        import subprocess
    \end{lstlisting}
    \item define our class  senors
    \begin{lstlisting}[style=mystyle]
    class sensor_data:
        def __init__(self):
            self.dht22 = DHT22()
            self.humidity,self.temperature=self.dht22.Read_DHT22_data()
            self.AS312=AS312(17)
            self.motion_detected =AS312.read_state()
            self.DF0026 =DFR0026()
            self.light_value=self.DF0026.Read_data()
            self.fname="sensor_data.csv"
    \end{lstlisting}
    \item We write and append our data to  the csv file
    \begin{lstlisting}[style=mystyle]
        def write_append_csv(self):
		data = { "Timestamp" : self.timestamp,
			"Temperature(oc)" : self.Temperature,
			"Humidity(%)" : self.humidity,
			"Light(lux)" :self.light_value,
			"Motion Detected": self.motion_detected
			}
		df = pd.DataFrame(data)
		if glob.glob(self.fname):	
			df.to_csv(self.fname,mode='a' ,index=False,header=False)
		else:
			df.to_csv(self.fname,mode='w' ,index=False)
    \end{lstlisting}
    \newpage
    \item Next we define our variables for testing  memory
    \begin{lstlisting}[style=mystyle]
    class Memory_tester():
        def __init__(self):
            self.units={"K":10e3,"M": 10e6,"G":10e9}
            self.regex ="\d{4}\.\[0-9]{1,3}[K,M,G]"
            self.fname="../bash_scrpits/memorytest.sh" 
            self.output_bash=subprocess.check_output(["bash",self.fname],universal_newlines=True)
    \end{lstlisting}
    \item next we check our memory
    \begin{lstlisting}[style=mystyle]
        def check_memory(self):
            try:
                if re.search(self.regex,self.output_bash):
                    value,unit=match.group(0).split()
                    try:
                        return float(value)*self.units[unit]
                    except KeyError:
                        raise ValueError(f"unknown unit: {unit}")
                
            except subprocess.CalledProcessError as e:
                raise ValueError(f"Error running script:{e.output}")
    \end{lstlisting}
    \item  we then  make an error if its useing  20 percent memory
    \begin{lstlisting}[style=mystyle]
        def error_check(self):
            mem=self.check_memory()
            max=32*10e9
            if mem >= 0.2* max:
                raise MemoryError("memory on pi is about to  used up")
    \end{lstlisting}
    \item to make sure  our class run from another python file 
    \begin{lstlisting}[style=mystyle]
        if __name__=="__main__":
            sensor_data()
            Memory_tester()
    \end{lstlisting}
\end{enumerate}
\subsection{Radio module}
This section is based off the github repository: \url{https://github.com/sbcshop/Lora-HAT-for-Raspberry-Pi}
here are the following approach for this module
\begin{enumerate}
    \item First import the following  libraries:
    \begin{lstlisting}[style=mystyle]
        #!/home/mistaherd/Documents/Github/meshnetwork_in_forest/env/lib/python3.11
        import time
        import serial
        import pandas as pd
        import numpy as np
        import threading
        import base64
        from memory_mangment import sensor_data
    \end{lstlisting}
    \item we define our  class and its  constants
    \begin{lstlisting}[style=mystyle]
        class Transciever:
            def __init__(self):
                self.transceive_ser=serial.Serial(port='/dev/ttyS0',baudrate=9600,parity=serial.PARITY_NONE,stopbits=serial.STOPBITS_ONE,bytesize=serial.EIGHTBITS,timeout=1)
                self.message="Hello world!"
                self.chunk_size=240
                self.txt_fname="/home/mistaherd/Documents/Github/meshnetwork_in_forest/Tests/transmited_text.txt"
                self.png_fname="/home/mistaherd/Documents/Github/meshnetwork_in_forest/Images_camera/camera_output_2024-05-19_13_25_18.png"
                self.csv_fname=sensor_data().fname
                self.timelimit=time.time()+6
                self.recived=self.transceive_ser.in_waiting
                self.event=threading.Event()
    \end{lstlisting}
    
    Where "self.transcive_ser" set our serial port up which in linux is  '/dev/ttyS0' we can  control timeout to be  6 seconds but for this section well keep it at 1,"self.event" it seeting  a threing event to occur in the code "
    \item Setup a interrupt
    \begin{lstlisting}[style=mystyle]
        def serial_interrupt(self):
		if self.recived:
			self.event.set()
    \end{lstlisting}
    
    If there is any information to be sent on the wireless channel this will stop all operations
    \item Make a process that will calculated the bytes  before sending the data

    \begin{lstlisting}[style=mystyle]
        def cal_bytes(self)-> int:
		    return len([bytes(self.data[i],'utf-8').hex() for i in range(len(self.data))])
    \end{lstlisting}
    \item Test sending and receiving  hello world!
    \begin{lstlisting}[style=mystyle]
        def transceive_test_message(self,transceive:bool):
            """send /recive a hello world"""
            if transceive:
                # self.message
                #transmite
                self.transceive_ser.write(bytes(self.message,'utf-8'))
                time.sleep(0.2)
            if not transceive:
                while time.time()< self.reive_timelimit:
                    self.transceive_ser.attachInterrupt(self.serial_interrupt)
                    if self.event.is_set():
                        data_read=self.transceive_ser.readline()
                        data=data_read.decode("utf-8")
                        print("message received:",data)
                        self.event.clear()
    \end{lstlisting}
    \item test send/receiving a txt file
    \begin{lstlisting}[style=mystyle]
        def transceive_test_txt_file(self,transceive:bool):
            """send /revive a txt file"""
            if transceive:
                with open(self.txt_fname,'r') as f:
                    data=f.read()

                self.transceive_ser.write(bytes(data,'utf-8'))
                time.sleep(0.2)
            if not transceive:
                while time.time()< self.timelimit:
                    self.transceive_ser.attachInterrupt(self.serial_interrupt)
                    if self.event.is_set():
                        data_read=self.transceive_ser.readline()
                        data=data_read.decode("utf-8")
                        print("message received:",data)
                        self.event.clear()
                        return data
    \end{lstlisting}
    \item Test sending and revecing csv file
    \begin{lstlisting}[style=mystyle]
        def transceive_test_csv(self,transceive:bool):
            if transceive:
                with open('/home/mistaherd/Documents/Github/meshnetwork_in_forest/main/sensor_data.csv','r') as f:
                    data=f.readlines()
                data=''.join(data)
                lora.write(bytes(data,'utf-8'))
                time.sleep(0.2)
            if not transceive:
                while time.time() <self.timelimit:
                    self.transceive_ser.attachInterrupt(self.serial_interrupt)
                    if self.event.is_set():
                        data=self.transceive_ser.readlines()
                        output=[data[i].decode()[:-1].split(",") for i in range(len(data))]
                        df=pd.DataFrame(output)
                        self.event.clear()
                        return df
    \end{lstlisting}
    \item Test sending and receiving an image file
    \begin{lstlisting}[style=mystyle]
        def Transcevie_png_file(self,transceive:bool):
            """Transmit a PNG file"""
            if transceive:
                with open(self.png_fname, 'rb') as f:
                    self.data = f.read()
                if self.cal_bytes()>self.chunk_size:
                    chunks=[data[i:i+self.chunk_size] for i in range(0,len(self.data),self.chunk_size)]
                    for chunk in range(len(chunks)):
                        encoded_chunk=base64.b64encode(chunk)
                        self.transceive_ser.write(encoded_chunk)
                else:
                    raise ValueError("Image file must be corrupted")
            if not transceive:
                output=[]
                self.transceive_ser.attachInterrupt(self.serial_interrupt)
                if self.event.is_set():
                    while(self.transceive_ser.read() != b''):
                        data_read = self.transceive_ser.read()
                        print("bytes reviced %a"%data_read)
                        output.append(base64.b64decode(data_read))
                    output=b"".join(output)
                    self.event.clear()
                    return output
    \end{lstlisting}
    \item For demo make sure to define the following:
    \begin{lstlisting}[style=mystyle]
        def transive_choice(self,arugement):
            """ run this for demo"""
            if not self.event.is_set():
                #transmit something
                self.transmit=True
                choice ={
                    1:lambda :self.transceive_test_message(self.transmit),
                    2:lambda :self.transceive_test_txt_file(self.transmit),
                    3:lambda :self.transceive_test_csv(self.transmit),
                    4:lambda :self.Transcevie_png_file(self.transmit)}
                choice[arugement]()
            #revived somthing
            self.transmit=False
            choice[self.user_message]()
    \end{lstlisting}
    \item have file as a module
    \begin{lstlisting}[style=mystyle]
        if __name__=='__main__':
	        Transciever()
            
    \end{lstlisting}
\end{enumerate}